<?php

namespace App\Console\Commands;

use App\Models\Group;
use App\Services\AIReadingChallengeGenerator;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Log;

class GenerateReadingChallenges extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'challenges:generate 
                            {--group= : ID du groupe sp√©cifique} 
                            {--force : Forcer la g√©n√©ration m√™me si un d√©fi actif existe}
                            {--type= : Type de d√©fi √† g√©n√©rer}
                            {--difficulty= : Niveau de difficult√©}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'G√©n√©rer des d√©fis de lecture IA pour les groupes actifs';

    /**
     * Execute the console command.
     */
    public function handle()
    {
        $this->info('üöÄ D√©marrage de la g√©n√©ration automatique de d√©fis IA...');

        $generator = new AIReadingChallengeGenerator();
        $groupId = $this->option('group');

        // Statistiques de g√©n√©ration
        $stats = [
            'total_groups' => 0,
            'eligible_groups' => 0,
            'challenges_created' => 0,
            'challenges_skipped' => 0,
            'errors' => 0,
            'start_time' => now()
        ];

        if ($groupId) {
            // G√©n√©rer pour un groupe sp√©cifique
            $group = Group::with('category')->find($groupId);
            
            if (!$group) {
                $this->error("‚ùå Groupe introuvable avec l'ID: {$groupId}");
                return 1;
            }

            $this->generateForGroup($generator, $group, $stats);
        } else {
            // G√©n√©ration automatique intelligente pour tous les groupes
            $this->generateAutomatically($generator, $stats);
        }

        $this->displaySummary($stats);
        return 0;
    }

    /**
     * G√©n√©ration automatique intelligente
     */
    private function generateAutomatically(AIReadingChallengeGenerator $generator, array &$stats)
    {
        $this->line('üß† Mode g√©n√©ration automatique intelligente activ√©...');

        // Obtenir les groupes √©ligibles pour de nouveaux d√©fis
        $eligibleGroups = $this->getEligibleGroups();
        $stats['total_groups'] = Group::where('status', 'active')->count();
        $stats['eligible_groups'] = $eligibleGroups->count();

        $this->line("üìä {$stats['total_groups']} groupes actifs, {$stats['eligible_groups']} √©ligibles pour nouveaux d√©fis");

        if ($eligibleGroups->isEmpty()) {
            $this->warn('‚ö†Ô∏è  Aucun groupe √©ligible trouv√©.');
            return;
        }

        $progressBar = $this->output->createProgressBar($eligibleGroups->count());
        $progressBar->start();

        foreach ($eligibleGroups as $group) {
            try {
                // Analyser le groupe pour d√©terminer le meilleur type de d√©fi
                $optimalSettings = $this->analyzeGroupForOptimalChallenge($group);
                
                if ($optimalSettings['should_generate']) {
                    $challenge = $generator->generateChallenge($group, $optimalSettings['options']);
                    $stats['challenges_created']++;
                } else {
                    $stats['challenges_skipped']++;
                }

            } catch (\Exception $e) {
                $stats['errors']++;
                \Log::error("Erreur g√©n√©ration automatique d√©fi pour groupe {$group->id}: " . $e->getMessage());
            }

            $progressBar->advance();
        }

        $progressBar->finish();
        $this->newLine();
    }

    /**
     * Obtenir les groupes √©ligibles pour de nouveaux d√©fis
     */
    private function getEligibleGroups()
    {
        return Group::where('status', 'active')
            ->with(['category', 'readingChallenges' => function($query) {
                $query->where('status', 'active')->where('end_date', '>', now());
            }])
            ->whereHas('users', function($query) {
                $query->where('status', 'accepted');
            }, '>=', 3) // Au moins 3 membres actifs
            ->get()
            ->filter(function($group) {
                // Filtrer les groupes qui n'ont pas de d√©fi actif ou qui en ont besoin d'un nouveau
                $activeChallenge = $group->readingChallenges->first();
                
                if (!$activeChallenge) {
                    return true; // Pas de d√©fi actif, √©ligible
                }
                
                // Si le d√©fi actuel se termine dans moins de 7 jours, pr√©parer le suivant
                return $activeChallenge->end_date->diffInDays(now()) <= 7;
            });
    }

    /**
     * Analyser un groupe pour d√©terminer le d√©fi optimal
     */
    private function analyzeGroupForOptimalChallenge(Group $group)
    {
        $analysis = [
            'should_generate' => true,
            'options' => [],
            'reasoning' => []
        ];

        // Analyser l'historique des d√©fis du groupe
        $recentChallenges = $group->readingChallenges()
            ->where('created_at', '>=', now()->subMonths(3))
            ->get();

        // √âviter la r√©p√©tition de types de d√©fis
        $recentTypes = $recentChallenges->pluck('challenge_type')->unique();
        
        // Analyser l'activit√© du groupe
        $recentActivity = $group->posts()
            ->where('created_at', '>=', now()->subWeeks(2))
            ->count();

        // Analyser la cat√©gorie du groupe
        $categoryName = $group->category->name ?? 'G√©n√©ral';

        // Logique de d√©cision intelligente
        if ($recentActivity < 2) {
            // Groupe peu actif, d√©fi facile pour stimuler
            $analysis['options']['difficulty'] = 'easy';
            $analysis['options']['type'] = 'monthly_genre';
            $analysis['reasoning'][] = 'Groupe peu actif - d√©fi facile pour relancer';
        } elseif ($recentActivity > 10) {
            // Groupe tr√®s actif, on peut proposer du challenging
            $analysis['options']['difficulty'] = 'hard';
            $analysis['reasoning'][] = 'Groupe tr√®s actif - d√©fi difficile';
        }

        // √âviter les doublons de types r√©cents
        $availableTypes = ['monthly_genre', 'author_focus', 'cultural_discovery', 'page_challenge'];
        $availableTypes = collect($availableTypes)->diff($recentTypes)->values();
        
        if ($availableTypes->isNotEmpty() && !isset($analysis['options']['type'])) {
            $analysis['options']['type'] = $availableTypes->random();
            $analysis['reasoning'][] = 'Type choisi pour √©viter r√©p√©tition';
        }

        // Analyse saisonni√®re (optionnel)
        $currentMonth = now()->month;
        if (in_array($currentMonth, [10, 11, 12]) && !$recentTypes->contains('classic_revival')) {
            $analysis['options']['type'] = 'classic_revival';
            $analysis['reasoning'][] = 'Saison automnale - focus sur les classiques';
        }

        return $analysis;
    }

    private function generateForGroup(AIReadingChallengeGenerator $generator, Group $group)
    {
        $this->line("üìö G√©n√©ration pour le groupe: {$group->name}");

        try {
            // V√©rifier si un d√©fi actif existe
            if (!$this->option('force')) {
                $hasActiveChallenge = $group->readingChallenges()
                    ->where('status', 'active')
                    ->where('end_date', '>', now())
                    ->exists();

                if ($hasActiveChallenge) {
                    $this->warn("‚ö†Ô∏è  Le groupe '{$group->name}' a d√©j√† un d√©fi actif. Utilisez --force pour forcer la g√©n√©ration.");
                    return;
                }
            }

            $options = array_filter([
                'type' => $this->option('type'),
                'difficulty' => $this->option('difficulty')
            ]);

            $challenge = $generator->generateChallenge($group, $options);

            $this->info("‚úÖ D√©fi cr√©√©: '{$challenge->title}'");
            $this->line("   Type: {$challenge->getTypeLabel()}");
            $this->line("   Difficult√©: " . ucfirst($challenge->difficulty_level));
            $this->line("   Cat√©gorie: " . ($group->category->name ?? 'G√©n√©ral'));

        } catch (\Exception $e) {
            $this->error("‚ùå Erreur pour le groupe '{$group->name}': " . $e->getMessage());
        }
    }

    private function generateForAllGroups(AIReadingChallengeGenerator $generator)
    {
        $this->line('üìö G√©n√©ration pour tous les groupes actifs...');

        $groups = Group::where('status', 'active')
            ->with('category')
            ->get();

        if ($groups->isEmpty()) {
            $this->warn('‚ö†Ô∏è  Aucun groupe actif trouv√©.');
            return;
        }

        $this->line("üìä {$groups->count()} groupe(s) trouv√©(s)");

        $progressBar = $this->output->createProgressBar($groups->count());
        $progressBar->start();

        $results = ['created' => 0, 'skipped' => 0, 'errors' => 0];

        foreach ($groups as $group) {
            try {
                // V√©rifier si un d√©fi actif existe
                if (!$this->option('force')) {
                    $hasActiveChallenge = $group->readingChallenges()
                        ->where('status', 'active')
                        ->where('end_date', '>', now())
                        ->exists();

                    if ($hasActiveChallenge) {
                        $results['skipped']++;
                        $progressBar->advance();
                        continue;
                    }
                }

                $options = array_filter([
                    'type' => $this->option('type'),
                    'difficulty' => $this->option('difficulty')
                ]);

                $challenge = $generator->generateChallenge($group, $options);
                $results['created']++;

            } catch (\Exception $e) {
                $results['errors']++;
                \Log::error("Erreur g√©n√©ration d√©fi pour groupe {$group->id}: " . $e->getMessage());
            }

            $progressBar->advance();
        }

        $progressBar->finish();
        $this->newLine(2);

        // Afficher les r√©sultats
        $this->info("üìä R√©sum√© de la g√©n√©ration:");
        $this->line("   ‚úÖ D√©fis cr√©√©s: {$results['created']}");
        $this->line("   ‚è≠Ô∏è  Groupes ignor√©s: {$results['skipped']}");
        $this->line("   ‚ùå Erreurs: {$results['errors']}");

            if ($results['created'] > 0) {
            $this->info("üéâ {$results['created']} nouveau(x) d√©fi(s) de lecture g√©n√©r√©(s) !");
        }
    }

    /**
     * Afficher le r√©sum√© de la g√©n√©ration
     */
    private function displaySummary(array $stats)
    {
        $duration = $stats['start_time']->diffInSeconds(now());
        
        $this->newLine();
        $this->info("üìä R√©sum√© de la g√©n√©ration automatique:");
        $this->line("   ‚è±Ô∏è  Dur√©e: {$duration}s");
        $this->line("   üìö Groupes analys√©s: {$stats['total_groups']}");
        $this->line("   ‚úÖ Groupes √©ligibles: {$stats['eligible_groups']}");
        $this->line("   üÜï D√©fis cr√©√©s: {$stats['challenges_created']}");
        $this->line("   ‚è≠Ô∏è  D√©fis ignor√©s: {$stats['challenges_skipped']}");
        $this->line("   ‚ùå Erreurs: {$stats['errors']}");

        if ($stats['challenges_created'] > 0) {
            $this->info("üéâ G√©n√©ration automatique termin√©e avec succ√®s !");
            $this->line("üí° Les nouveaux d√©fis sont maintenant disponibles dans les groupes.");
        } elseif ($stats['eligible_groups'] === 0) {
            $this->warn("‚ö†Ô∏è  Aucun groupe √©ligible pour de nouveaux d√©fis.");
            $this->line("üí° Les groupes ont probablement d√©j√† des d√©fis actifs.");
        } else {
            $this->comment("‚ÑπÔ∏è  Aucun nouveau d√©fi g√©n√©r√© cette fois-ci.");
        }

        // Conseils pour l'optimisation
        if ($stats['errors'] > 0) {
            $this->warn("‚ö†Ô∏è  {$stats['errors']} erreur(s) d√©tect√©e(s). Consultez les logs pour plus de d√©tails.");
        }

        if ($stats['total_groups'] > 0) {
            $successRate = round(($stats['challenges_created'] / $stats['eligible_groups']) * 100, 1);
            $this->line("üìà Taux de succ√®s: {$successRate}%");
        }
    }
}